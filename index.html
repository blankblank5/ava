<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8">
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  <title>Elemental Game</title>
  <style>
    body { margin: 0; overflow: hidden; background-color: #87ceeb; }
  </style>
</head>
<body>
  <script type="module">
    import * as THREE from 'https://cdn.skypack.dev/three@0.136.0';

    // --- GUI Setup ---
    const gui = document.createElement('div');
    gui.innerHTML = `
      <div style="position: absolute; top: 50%; left: 50%; width: 10px; height: 10px; background: white; border-radius: 50%; transform: translate(-50%, -50%); pointer-events: none; mix-blend-mode: difference; z-index: 10;"></div>
      
      <div style="position: absolute; bottom: 20px; left: 20px; color: white; font-family: sans-serif; text-shadow: 2px 2px 0 #000; pointer-events: none; user-select: none;">
        <div style="margin-bottom: 15px;">
          <h3 style="margin:0; color: yellow; font-size: 24px;">LVL <span id="lvl-display">1</span></h3>
          <div style="width: 200px; height: 10px; background: #333; margin-top: 5px; border: 1px solid white;">
            <div id="xp-bar" style="width: 0%; height: 100%; background: lime; transition: width 0.2s;"></div>
          </div>
        </div>

        <h2 id="el-name" style="margin: 0; font-size: 30px;">AIR</h2>
        <div style="background: rgba(0,0,0,0.6); padding: 15px; border-radius: 8px; margin-top: 5px; min-width: 250px;">
          <div id="slot-0" style="margin-bottom:4px;">[L-Click] Shot</div>
          <div id="slot-1" style="margin-bottom:4px;">[Q] Blade</div>
          <div id="slot-2" style="margin-bottom:4px;">[E] Dash</div>
          <div id="slot-3" style="margin-bottom:4px;">[R] Tornado</div>
        </div>
        <div id="cooldown-msg" style="color: red; font-weight: bold; opacity: 0; transition: opacity 0.1s; margin-top: 5px;">ON COOLDOWN!</div>
      </div>
    `;
    document.body.appendChild(gui);

    // --- Scene Setup ---
    const scene = new THREE.Scene();
    scene.background = new THREE.Color(0x87ceeb);
    scene.fog = new THREE.Fog(0x87ceeb, 20, 120);

    const camera = new THREE.PerspectiveCamera(75, window.innerWidth / window.innerHeight, 0.1, 1000);
    const renderer = new THREE.WebGLRenderer({ antialias: true });
    renderer.setSize(window.innerWidth, window.innerHeight);
    renderer.shadowMap.enabled = true;
    document.body.appendChild(renderer.domElement);

    // --- Lighting ---
    const light = new THREE.DirectionalLight(0xffffff, 1);
    light.position.set(50, 100, 50);
    light.castShadow = true;
    scene.add(new THREE.AmbientLight(0x404040, 1.5));
    scene.add(light);

    // --- Environment ---
    const floorGeo = new THREE.PlaneGeometry(300, 300);
    const floorMat = new THREE.MeshStandardMaterial({ color: 0x33aa33 });
    const floor = new THREE.Mesh(floorGeo, floorMat);
    floor.rotation.x = -Math.PI / 2;
    floor.receiveShadow = true;
    scene.add(floor);

    const grid = new THREE.GridHelper(300, 150, 0x000000, 0x225522);
    grid.position.y = 0.05;
    scene.add(grid);

    // --- Game Objects ---
    const dummies = [];
    const solidWalls = [];
    const projectiles = [];

    // Dummies
    const dummyGeo = new THREE.BoxGeometry(1, 2, 1);
    const dummyMat = new THREE.MeshStandardMaterial({ color: 0xff0000 });

    function createDummy() {
      const dummy = new THREE.Mesh(dummyGeo, dummyMat.clone());
      dummy.position.set(Math.random() * 60 - 30, 1, Math.random() * -40 - 10);
      dummy.castShadow = true;
      scene.add(dummy);
      dummies.push({ mesh: dummy, velocityY: 0, hp: 100, maxHp: 100 });
    }
    for(let i=0; i<8; i++) createDummy();

    // --- STATS CONFIGURATION ---
    const ELEMENTS = {
      AIR: { 
        name: 'AIR', color: 0xffffff, 
        moves: [
          { name: 'Air Shot',   dmg: 12,  cd: 300,  speed: 60, grav: 0.0, life: 300, shape: 'sharp' },
          { name: 'Wind Blade', dmg: 35,  cd: 2000, speed: 45, grav: 0.0, life: 300, shape: 'flat' },
          { name: 'Air Dash',   dmg: 0,   cd: 500,  type: 'dash' },
          { name: 'Tornado',    dmg: 8,   cd: 6000, speed: 20, grav: 0.0, life: 400, shape: 'sharp', count: 6, spread: 0.5 }
        ]
      },
      EARTH: { 
        name: 'EARTH', color: 0x8b4513, 
        moves: [
          { name: 'Pebble',     dmg: 25,  cd: 800,  speed: 35, grav: 0.8, life: 60,  shape: 'pebble' },
          { name: 'Boulder',    dmg: 80,  cd: 5000, speed: 25, grav: 1.2, life: 100, shape: 'rock' },
          { name: 'Rock Wall',  dmg: 0,   cd: 4000, type: 'wall' },
          { name: 'Shotgun',    dmg: 12,  cd: 7000, speed: 40, grav: 0.5, life: 50,  shape: 'pebble', count: 10, spread: 0.8 }
        ]
      },
      FIRE: { 
        name: 'FIRE', color: 0xff4500, 
        moves: [
          { name: 'Firebolt',   dmg: 15,  cd: 400,  speed: 55, grav: 0.02, life: 250, shape: 'spike' },
          { name: 'Fireball',   dmg: 50,  cd: 3500, speed: 30, grav: 0.1,  life: 200, shape: 'sphere' },
          { name: 'Flamethrow', dmg: 5,   cd: 4000, speed: 18, grav: -0.08, life: 150, shape: 'spike', count: 20, spread: 1.2, auto: true },
          { name: 'Meteor',     dmg: 120, cd: 12000, type: 'meteor' }
        ]
      },
      WATER: { 
        name: 'WATER', color: 0x0088ff, 
        moves: [
          { name: 'Droplet',    dmg: 14,  cd: 350,  speed: 45, grav: 0.1, life: 150, shape: 'sphere' },
          { name: 'Ice Lance',  dmg: 45,  cd: 2500, speed: 80, grav: 0.05, life: 200, shape: 'long' },
          { name: 'Tidal Wave', dmg: 20,  cd: 4000, speed: 20, grav: 0.0, life: 100, shape: 'flat', scale: 3 },
          { name: 'Bubbles',    dmg: 6,   cd: 5000, speed: 15, grav: -0.05, life: 300, shape: 'sphere', count: 12, spread: 1.0 }
        ]
      }
    };

    let currentElement = ELEMENTS.AIR;
    const cooldowns = {
      AIR: [0, 0, 0, 0], EARTH: [0, 0, 0, 0], FIRE: [0, 0, 0, 0], WATER: [0, 0, 0, 0]
    };

    // --- Player State ---
    let level = 1, currentXP = 0, xpRequired = 100, airCharges = 3, isAirCoolingDown = false;

    // --- Hands ---
    const handMat = new THREE.MeshStandardMaterial({ color: 0xffffff });
    const handGeo = new THREE.BoxGeometry(0.3, 0.3, 0.8);
    const leftHand = new THREE.Mesh(handGeo, handMat.clone());
    const rightHand = new THREE.Mesh(handGeo, handMat.clone());
    leftHand.position.set(-1.0, -0.5, -0.8);
    rightHand.position.set(1.0, -0.5, -0.8);
    const handGroup = new THREE.Group();
    handGroup.add(leftHand);
    handGroup.add(rightHand);
    scene.add(handGroup);

    // --- Controls ---
    let moveForward = false, moveBackward = false, moveLeft = false, moveRight = false;
    let isSprinting = false, canJump = true, velocityY = 0, yaw = 0, pitch = 0, moveTimer = 0;
    let playerVelocity = new THREE.Vector3(); 

    document.body.addEventListener('click', () => document.body.requestPointerLock());
    document.addEventListener('mousemove', (e) => {
      if (document.pointerLockElement === document.body) {
        yaw -= e.movementX * 0.002;
        pitch -= e.movementY * 0.002;
        pitch = Math.max(-Math.PI / 2, Math.min(Math.PI / 2, pitch));
        camera.rotation.order = "YXZ";
        camera.rotation.y = yaw;
        camera.rotation.x = pitch;
      }
    });

    document.addEventListener('mousedown', (e) => { if(document.pointerLockElement === document.body && e.button === 0) useMove(0); });
    document.addEventListener('keydown', (e) => {
      if (e.code === 'KeyQ') useMove(1); 
      if (e.code === 'KeyE') useMove(2);
      if (e.code === 'KeyR') useMove(3);
      if (e.code === 'KeyW') moveForward = true;
      if (e.code === 'KeyS') moveBackward = true;
      if (e.code === 'KeyA') moveLeft = true;
      if (e.code === 'KeyD') moveRight = true;
      if (e.code === 'ShiftLeft') isSprinting = true;
      if (e.code === 'Space' && canJump) { velocityY = 5.0; canJump = false; }
      
      if (e.key === '1') switchElement(ELEMENTS.AIR);
      if (e.key === '2') switchElement(ELEMENTS.EARTH);
      if (e.key === '3') switchElement(ELEMENTS.FIRE);
      if (e.key === '4') switchElement(ELEMENTS.WATER);
    });

    document.addEventListener('keyup', (e) => {
      if (e.code === 'KeyW') moveForward = false;
      if (e.code === 'KeyS') moveBackward = false;
      if (e.code === 'KeyA') moveLeft = false;
      if (e.code === 'KeyD') moveRight = false;
      if (e.code === 'ShiftLeft') isSprinting = false;
    });

    // --- Logic ---
    function switchElement(elem) {
      currentElement = elem;
      document.getElementById('el-name').innerText = elem.name;
      document.getElementById('el-name').style.color = '#' + elem.color.toString(16);
      leftHand.material.color.setHex(elem.color);
      rightHand.material.color.setHex(elem.color);
      updateUI();
    }

    function updateUI() {
      const moves = currentElement.moves;
      for(let i=0; i<4; i++) {
        const el = document.getElementById(`slot-${i}`);
        const key = i===0 ? "L-Click" : i===1 ? "Q" : i===2 ? "E" : "R";
        let text = `[${key}] ${moves[i].name}`;
        if (moves[i].dmg > 0) text += ` (${moves[i].dmg})`;
        
        const readyTime = cooldowns[currentElement.name][i];
        const remaining = Math.max(0, Math.ceil((readyTime - Date.now()) / 1000));
        
        if (remaining > 0) {
            el.style.color = "gray";
            el.innerText = text + ` (${remaining}s)`;
        } else {
            el.style.color = "white";
            el.innerText = text;
        }
        if (currentElement.name === 'AIR' && i === 2) {
           el.innerHTML = `[E] Air Dash (<span style="color:${isAirCoolingDown?'red':'white'}">${airCharges}</span>/3)`;
        }
      }
    }

    function addXP(amount) {
      currentXP += amount;
      if (currentXP >= xpRequired) {
        currentXP -= xpRequired;
        level++;
        xpRequired = Math.floor(xpRequired * 1.2);
        const flash = document.createElement('div');
        flash.style.cssText = "position:absolute; inset:0; background:white; opacity:0.6; pointer-events:none;";
        document.body.appendChild(flash);
        setTimeout(() => flash.remove(), 100);
      }
      document.getElementById('lvl-display').innerText = level;
      document.getElementById('xp-bar').style.width = Math.min(100, (currentXP/xpRequired)*100) + '%';
    }

    function useMove(index) {
      const now = Date.now();
      const stats = currentElement.moves[index];
      
      if (now < cooldowns[currentElement.name][index]) {
        if (!(currentElement.name === 'AIR' && index === 2)) {
            const msg = document.getElementById('cooldown-msg');
            msg.style.opacity = 1; setTimeout(() => msg.style.opacity = 0, 300);
            return;
        }
      }

      if (stats.cd) cooldowns[currentElement.name][index] = now + stats.cd;
      updateUI();

      rightHand.position.z = -1.5; setTimeout(() => rightHand.position.z = -0.8, 100);
      const direction = new THREE.Vector3(0, 0, -1).applyQuaternion(camera.quaternion);
      const spawnPos = camera.position.clone().addScaledVector(direction, 1);

      if (stats.type === 'dash') {
        if (isAirCoolingDown || airCharges <= 0) return;
        airCharges--;
        if (direction.y > 0.4) {
           velocityY = 25; playerVelocity.addScaledVector(direction.clone().setY(0).normalize(), 10);
        } else {
           playerVelocity.addScaledVector(direction, 40); velocityY = 5; 
        }
        if (airCharges <= 0) {
          isAirCoolingDown = true;
          setTimeout(() => { airCharges = 3; isAirCoolingDown = false; updateUI(); }, 3000);
        }
        updateUI(); return;
      }

      if (stats.type === 'wall') {
        if (solidWalls.length >= 3) { scene.remove(solidWalls.shift().mesh); }
        const wallGeo = new THREE.BoxGeometry(6, 4, 1);
        const wallMat = new THREE.MeshStandardMaterial({ color: 0x555555 });
        const wall = new THREE.Mesh(wallGeo, wallMat);
        const wallPos = camera.position.clone().addScaledVector(direction.setY(0).normalize(), 4);
        wallPos.y = 2; wall.position.copy(wallPos);
        wall.lookAt(camera.position.x, wallPos.y, camera.position.z);
        scene.add(wall); solidWalls.push({ mesh: wall, hp: 10 });
        return;
      }

      if (stats.type === 'meteor') {
          let target = camera.position.clone().addScaledVector(direction, 40);
          if (direction.y < -0.1) {
              const t = -camera.position.y / direction.y;
              if(t > 0) target = camera.position.clone().addScaledVector(direction, t);
          }
          const skyPos = target.clone().add(new THREE.Vector3(0, 50, 0));
          createProjectile(skyPos, target.sub(skyPos).normalize(), 4.0, 0xff2200, 40, 0, 'spike', 120, 200);
          return;
      }

      for (let i = 0; i < (stats.count || 1); i++) {
        setTimeout(() => {
            let finalDir = direction.clone();
            if (stats.spread > 0) {
                finalDir.x += (Math.random() - 0.5) * stats.spread;
                finalDir.y += (Math.random() - 0.5) * stats.spread;
                finalDir.z += (Math.random() - 0.5) * stats.spread;
                finalDir.normalize();
            }
            createProjectile(spawnPos, finalDir, 0.2, currentElement.color, stats.speed, stats.grav, stats.shape, stats.dmg, stats.life, stats.scale);
        }, stats.auto ? i * 50 : 0);
      }
    }

    function createProjectile(pos, velDir, size, color, speed, gravity, shape, dmg, life, scaleMult=1) {
      let s = size * scaleMult, geometry;
      if (shape === 'rock') geometry = new THREE.DodecahedronGeometry(s * 2, 0); 
      else if (shape === 'pebble') geometry = new THREE.TetrahedronGeometry(s, 1);
      else if (shape === 'spike') geometry = new THREE.OctahedronGeometry(s, 0);
      else if (shape === 'sharp') geometry = new THREE.TetrahedronGeometry(s, 0);
      else if (shape === 'flat') geometry = new THREE.BoxGeometry(s*5, s/2, s);
      else if (shape === 'long') geometry = new THREE.BoxGeometry(s/2, s/2, s*8);
      else geometry = new THREE.SphereGeometry(s, 8, 8);

      const mat = new THREE.MeshStandardMaterial({ color: color, emissive: color, emissiveIntensity: 0.6, roughness: 0.8 });
      const mesh = new THREE.Mesh(geometry, mat);
      mesh.position.copy(pos);
      if (['rock','pebble','spike'].includes(shape)) mesh.rotation.set(Math.random()*3, Math.random()*3, Math.random()*3);
      else mesh.lookAt(pos.clone().add(velDir));
      
      scene.add(mesh);
      projectiles.push({ mesh, velocity: velDir.multiplyScalar(speed), gravity, life, dmg, shape });
    }

    // --- Main Loop ---
    function animate() {
      requestAnimationFrame(animate);
      const delta = 0.016;

      if (Date.now() % 10 === 0) updateUI();

      const snap = 2;
      const gridX = Math.round(camera.position.x / snap) * snap;
      const gridZ = Math.round(camera.position.z / snap) * snap;
      floor.position.set(gridX, 0, gridZ);
      grid.position.set(gridX, 0.05, gridZ);

      if (document.pointerLockElement === document.body) {
        const fwd = new THREE.Vector3(0, 0, -1).applyAxisAngle(new THREE.Vector3(0, 1, 0), yaw);
        const rgt = new THREE.Vector3(1, 0, 0).applyAxisAngle(new THREE.Vector3(0, 1, 0), yaw);
        const intent = new THREE.Vector3();
        if (moveForward) intent.add(fwd);
        if (moveBackward) intent.add(fwd.clone().negate());
        if (moveRight) intent.add(rgt);
        if (moveLeft) intent.add(rgt.clone().negate());
        intent.normalize().multiplyScalar((isSprinting ? 18.0 : 10.0) * delta);
        playerVelocity.add(intent);
      }

      playerVelocity.x -= playerVelocity.x * 5.0 * delta;
      playerVelocity.z -= playerVelocity.z * 5.0 * delta;
      
      const nextPos = camera.position.clone().add(new THREE.Vector3(playerVelocity.x * delta * 3, 0, playerVelocity.z * delta * 3));
      let wallHit = false;
      for(let w of solidWalls) {
          const localPos = nextPos.clone();
          w.mesh.worldToLocal(localPos);
          if (Math.abs(localPos.x) <= 3.5 && localPos.y >= -3.0 && localPos.y <= 2.5 && Math.abs(localPos.z) <= 1.0) { 
              wallHit = true; break; 
          }
      }
      
      if(!wallHit) { camera.position.x += playerVelocity.x * delta * 3; camera.position.z += playerVelocity.z * delta * 3; }
      else { playerVelocity.set(0,0,0); }

      velocityY -= 9.8 * delta;
      camera.position.y += velocityY * delta;
      if (camera.position.y < 1.7) { camera.position.y = 1.7; velocityY = 0; canJump = true; }

      for (let i = projectiles.length - 1; i >= 0; i--) {
        const p = projectiles[i];
        p.mesh.position.addScaledVector(p.velocity, delta);
        p.velocity.y -= p.gravity;
        if (['rock','pebble','spike'].includes(p.shape)) { p.mesh.rotation.x += 0.1; p.mesh.rotation.y += 0.1; }

        p.life--;
        if (p.mesh.position.y <= 0 || p.life <= 0) { scene.remove(p.mesh); projectiles.splice(i, 1); continue; }

        let hit = false;
        for(let w = solidWalls.length - 1; w >= 0; w--) {
            const localPos = p.mesh.position.clone();
            solidWalls[w].mesh.worldToLocal(localPos);
            if (Math.abs(localPos.x) <= 3.0 && Math.abs(localPos.y) <= 2.0 && Math.abs(localPos.z) <= 0.5) {
                hit = true; solidWalls[w].hp -= p.dmg;
                solidWalls[w].mesh.material.color.setHex(0xffaaaa);
                const flashedMesh = solidWalls[w].mesh;
                setTimeout(()=> { if(flashedMesh.parent) flashedMesh.material.color.setHex(0x555555); }, 50);
                if(solidWalls[w].hp <= 0) { scene.remove(solidWalls[w].mesh); solidWalls.splice(w, 1); }
                break;
            }
        }
        
        if (!hit) {
            for (let d = dummies.length - 1; d >= 0; d--) {
                if (p.mesh.position.distanceTo(dummies[d].mesh.position) < 2.5) {
                    dummies[d].hp -= p.dmg; hit = true;
                    dummies[d].mesh.material.color.setHex(0xffffff);
                    setTimeout(() => dummies[d].mesh.material.color.setHex(0xff0000), 100);
                    if (dummies[d].hp <= 0) {
                        scene.remove(dummies[d].mesh); dummies.splice(d, 1); addXP(25);
                        setTimeout(createDummy, 3000);
                    } else { dummies[d].velocityY = 0.2; }
                    break;
                }
            }
        }

        if (hit) { scene.remove(p.mesh); projectiles.splice(i, 1); }
      }

      dummies.forEach(d => {
          d.mesh.position.y += d.velocityY; d.velocityY -= 0.01;
          if (d.mesh.position.y < 1) { d.mesh.position.y = 1; d.velocityY = 0; }
      });

      handGroup.position.copy(camera.position); handGroup.rotation.copy(camera.rotation);
      if ((moveForward||moveBackward||moveLeft||moveRight) && canJump) {
          moveTimer += 0.15;
          leftHand.position.y = -0.5 + Math.sin(moveTimer)*0.05;
          rightHand.position.y = -0.5 + Math.sin(moveTimer)*0.05;
      }

      renderer.render(scene, camera);
    }
    animate();

    window.addEventListener('resize', () => {
      camera.aspect = window.innerWidth / window.innerHeight; camera.updateProjectionMatrix();
      renderer.setSize(window.innerWidth, window.innerHeight);
    });
  </script>
</body>
</html>
