import * as THREE from 'https://cdn.skypack.dev/three@0.136.0';

// --- GUI Setup ---
const gui = document.createElement('div');
gui.innerHTML = `
  <div style="position: absolute; top: 50%; left: 50%; width: 10px; height: 10px; background: white; border-radius: 50%; transform: translate(-50%, -50%); pointer-events: none; mix-blend-mode: difference; z-index: 10;"></div>
  
  <div style="position: absolute; bottom: 20px; left: 20px; color: white; font-family: sans-serif; text-shadow: 2px 2px 0 #000; pointer-events: none; user-select: none;">
    <div style="margin-bottom: 15px;">
      <h3 style="margin:0; color: yellow; font-size: 24px;">LVL <span id="lvl-display">1</span></h3>
      <div style="width: 200px; height: 10px; background: #333; margin-top: 5px; border: 1px solid white;">
        <div id="xp-bar" style="width: 0%; height: 100%; background: lime; transition: width 0.2s;"></div>
      </div>
    </div>

    <h2 id="el-name" style="margin: 0; font-size: 30px;">AIR</h2>
    <div style="background: rgba(0,0,0,0.6); padding: 15px; border-radius: 8px; margin-top: 5px; min-width: 250px;">
      <div id="slot-0" style="margin-bottom:4px;">[L-Click] Shot</div>
      <div id="slot-1" style="margin-bottom:4px;">[Q] Blade</div>
      <div id="slot-2" style="margin-bottom:4px;">[E] Dash</div>
      <div id="slot-3" style="margin-bottom:4px;">[R] Tornado</div>
    </div>
    <div id="cooldown-msg" style="color: red; font-weight: bold; opacity: 0; transition: opacity 0.1s; margin-top: 5px;">ON COOLDOWN!</div>
  </div>
`;
document.body.appendChild(gui);

// --- Scene Setup ---
const scene = new THREE.Scene();
scene.background = new THREE.Color(0x87ceeb);
scene.fog = new THREE.Fog(0x87ceeb, 20, 120);

const camera = new THREE.PerspectiveCamera(75, window.innerWidth / window.innerHeight, 0.1, 1000);
const renderer = new THREE.WebGLRenderer({ antialias: true });
renderer.setSize(window.innerWidth, window.innerHeight);
renderer.shadowMap.enabled = true;
document.body.appendChild(renderer.domElement);

// --- Lighting ---
const light = new THREE.DirectionalLight(0xffffff, 1);
light.position.set(50, 100, 50);
light.castShadow = true;
scene.add(new THREE.AmbientLight(0x404040, 1.5));
scene.add(light);

// --- Environment ---
const floorGeo = new THREE.PlaneGeometry(300, 300);
const floorMat = new THREE.MeshStandardMaterial({ color: 0x33aa33 });
const floor = new THREE.Mesh(floorGeo, floorMat);
floor.rotation.x = -Math.PI / 2;
floor.receiveShadow = true;
scene.add(floor);

const grid = new THREE.GridHelper(300, 150, 0x000000, 0x225522);
grid.position.y = 0.05;
scene.add(grid);

// --- Game Objects ---
const dummies = [];
const solidWalls = [];
const projectiles = [];

// Dummies
const dummyGeo = new THREE.BoxGeometry(1, 2, 1);
const dummyMat = new THREE.MeshStandardMaterial({ color: 0xff0000 });

function createDummy() {
  const dummy = new THREE.Mesh(dummyGeo, dummyMat.clone());
  dummy.position.set(Math.random() * 60 - 30, 1, Math.random() * -40 - 10);
  dummy.castShadow = true;
  scene.add(dummy);
  dummies.push({ mesh: dummy, velocityY: 0, hp: 100, maxHp: 100 });
}
for(let i=0; i<8; i++) createDummy();

// --- STATS CONFIGURATION ---
// This controls the balance of the entire game
const ELEMENTS = {
  AIR: { 
    name: 'AIR', color: 0xffffff, 
    moves: [
      { name: 'Air Shot',   dmg: 12,  cd: 300,  speed: 60, grav: 0.0, life: 300, shape: 'sharp' }, // Fast, Far, Low Dmg
      { name: 'Wind Blade', dmg: 35,  cd: 2000, speed: 45, grav: 0.0, life: 300, shape: 'flat' },  // Med Dmg, Med CD
      { name: 'Air Dash',   dmg: 0,   cd: 500,  type: 'dash' },                                    // Utility
      { name: 'Tornado',    dmg: 8,   cd: 6000, speed: 20, grav: 0.0, life: 400, shape: 'sharp', count: 6, spread: 0.5 } // Multi-hit
    ]
  },
  EARTH: { 
    name: 'EARTH', color: 0x8b4513, 
    moves: [
      { name: 'Pebble',     dmg: 25,  cd: 800,  speed: 35, grav: 0.8, life: 60,  shape: 'pebble' }, // High Dmg, Short Range (Gravity)
      { name: 'Boulder',    dmg: 80,  cd: 5000, speed: 25, grav: 1.2, life: 100, shape: 'rock' },   // Huge Dmg, Heavy, Long CD
      { name: 'Rock Wall',  dmg: 0,   cd: 4000, type: 'wall' },                                     // Utility
      { name: 'Shotgun',    dmg: 12,  cd: 7000, speed: 40, grav: 0.5, life: 50,  shape: 'pebble', count: 10, spread: 0.8 } // Close range burst
    ]
  },
  FIRE: { 
    name: 'FIRE', color: 0xff4500, 
    moves: [
      { name: 'Firebolt',   dmg: 15,  cd: 400,  speed: 55, grav: 0.02, life: 250, shape: 'spike' }, // Long Range, Fast CD
      { name: 'Fireball',   dmg: 50,  cd: 3500, speed: 30, grav: 0.1,  life: 200, shape: 'sphere' }, // Strong, Med CD
      { name: 'Flamethrow', dmg: 5,   cd: 4000, speed: 18, grav: -0.08, life: 150, shape: 'spike', count: 20, spread: 1.2, auto: true }, // Wide floating fire stream
      { name: 'Meteor',     dmg: 120, cd: 12000, type: 'meteor' }                                    // Ultimate Nuke, Huge CD
    ]
  },
  WATER: { 
    name: 'WATER', color: 0x0088ff, 
    moves: [
      { name: 'Droplet',    dmg: 14,  cd: 350,  speed: 45, grav: 0.1, life: 150, shape: 'sphere' }, // Balanced
      { name: 'Ice Lance',  dmg: 45,  cd: 2500, speed: 80, grav: 0.05, life: 200, shape: 'long' },  // Sniper
      { name: 'Tidal Wave', dmg: 20,  cd: 4000, speed: 20, grav: 0.0, life: 100, shape: 'flat', scale: 3 }, // Wide hitbox
      { name: 'Bubbles',    dmg: 6,   cd: 5000, speed: 15, grav: -0.05, life: 300, shape: 'sphere', count: 12, spread: 1.0 } // Float up
    ]
  }
};

let currentElement = ELEMENTS.AIR;
// Track cooldowns for every move of every element independently
const cooldowns = {
  AIR: [0, 0, 0, 0],
  EARTH: [0, 0, 0, 0],
  FIRE: [0, 0, 0, 0],
  WATER: [0, 0, 0, 0]
};

// --- Player State ---
let level = 1;
let currentXP = 0;
let xpRequired = 100;
let airCharges = 3; 
let isAirCoolingDown = false;

// --- Hands ---
const handMat = new THREE.MeshStandardMaterial({ color: 0xffffff });
const handGeo = new THREE.BoxGeometry(0.3, 0.3, 0.8);
const leftHand = new THREE.Mesh(handGeo, handMat.clone());
const rightHand = new THREE.Mesh(handGeo, handMat.clone());
leftHand.position.set(-1.0, -0.5, -0.8);
rightHand.position.set(1.0, -0.5, -0.8);
const handGroup = new THREE.Group();
handGroup.add(leftHand);
handGroup.add(rightHand);
scene.add(handGroup);

// --- Controls ---
let moveForward = false, moveBackward = false, moveLeft = false, moveRight = false;
let isSprinting = false;
let canJump = true;
let velocityY = 0;
let playerVelocity = new THREE.Vector3(); 
let yaw = 0, pitch = 0;
let moveTimer = 0;

document.body.addEventListener('click', () => document.body.requestPointerLock());
document.addEventListener('mousemove', (e) => {
  if (document.pointerLockElement === document.body) {
    yaw -= e.movementX * 0.002;
    pitch -= e.movementY * 0.002;
    pitch = Math.max(-Math.PI / 2, Math.min(Math.PI / 2, pitch));
    camera.rotation.order = "YXZ";
    camera.rotation.y = yaw;
    camera.rotation.x = pitch;
  }
});

document.addEventListener('mousedown', (e) => { if(document.pointerLockElement === document.body && e.button === 0) useMove(0); });
document.addEventListener('keydown', (e) => {
  if (e.code === 'KeyQ') useMove(1); 
  if (e.code === 'KeyE') useMove(2);
  if (e.code === 'KeyR') useMove(3);
  if (e.code === 'KeyW') moveForward = true;
  if (e.code === 'KeyS') moveBackward = true;
  if (e.code === 'KeyA') moveLeft = true;
  if (e.code === 'KeyD') moveRight = true;
  if (e.code === 'ShiftLeft') isSprinting = true;
  if (e.code === 'Space' && canJump) { velocityY = 5.0; canJump = false; }
  
  if (e.key === '1') switchElement(ELEMENTS.AIR);
  if (e.key === '2') switchElement(ELEMENTS.EARTH);
  if (e.key === '3') switchElement(ELEMENTS.FIRE);
  if (e.key === '4') switchElement(ELEMENTS.WATER);
});

document.addEventListener('keyup', (e) => {
  if (e.code === 'KeyW') moveForward = false;
  if (e.code === 'KeyS') moveBackward = false;
  if (e.code === 'KeyA') moveLeft = false;
  if (e.code === 'KeyD') moveRight = false;
  if (e.code === 'ShiftLeft') isSprinting = false;
});

// --- Logic ---
function switchElement(elem) {
  currentElement = elem;
  document.getElementById('el-name').innerText = elem.name;
  document.getElementById('el-name').style.color = '#' + elem.color.toString(16);
  leftHand.material.color.setHex(elem.color);
  rightHand.material.color.setHex(elem.color);
  updateUI();
}

function updateUI() {
  const moves = currentElement.moves;
  for(let i=0; i<4; i++) {
    const el = document.getElementById(`slot-${i}`);
    const key = i===0 ? "L-Click" : i===1 ? "Q" : i===2 ? "E" : "R";
    let text = `[${key}] ${moves[i].name}`;
    
    // Add info
    if (moves[i].dmg > 0) text += ` (${moves[i].dmg})`;
    
    // Check Cooldown
    const readyTime = cooldowns[currentElement.name][i];
    const remaining = Math.max(0, Math.ceil((readyTime - Date.now()) / 1000));
    
    if (remaining > 0) {
        el.style.color = "gray";
        el.innerText = text + ` (${remaining}s)`;
    } else {
        el.style.color = "white";
        el.innerText = text;
    }
    
    // Special Dash Text
    if (currentElement.name === 'AIR' && i === 2) {
       el.innerHTML = `[E] Air Dash (<span style="color:${isAirCoolingDown?'red':'white'}">${airCharges}</span>/3)`;
    }
  }
}

// XP Logic
function addXP(amount) {
  currentXP += amount;
  if (currentXP >= xpRequired) {
    currentXP -= xpRequired;
    level++;
    xpRequired = Math.floor(xpRequired * 1.2);
    // Level Up Flash
    const flash = document.createElement('div');
    flash.style.cssText = "position:absolute; inset:0; background:white; opacity:0.6; pointer-events:none;";
    document.body.appendChild(flash);
    setTimeout(() => flash.remove(), 100);
  }
  document.getElementById('lvl-display').innerText = level;
  document.getElementById('xp-bar').style.width = Math.min(100, (currentXP/xpRequired)*100) + '%';
}

function useMove(index) {
  const now = Date.now();
  const stats = currentElement.moves[index];
  
  // Check Cooldown
  if (now < cooldowns[currentElement.name][index]) {
    // Exception for Air Dash (uses charges instead of time)
    if (!(currentElement.name === 'AIR' && index === 2)) {
        const msg = document.getElementById('cooldown-msg');
        msg.style.opacity = 1;
        setTimeout(() => msg.style.opacity = 0, 300);
        return;
    }
  }

  // Set Cooldown
  if (stats.cd) cooldowns[currentElement.name][index] = now + stats.cd;
  updateUI();

  // Animation
  rightHand.position.z = -1.5;
  setTimeout(() => rightHand.position.z = -0.8, 100);

  const direction = new THREE.Vector3(0, 0, -1).applyQuaternion(camera.quaternion);
  const spawnPos = camera.position.clone().addScaledVector(direction, 1);

  // --- SPECIAL MOVES (Walls, Meteors, Dashes) ---
  if (stats.type === 'dash') {
    if (isAirCoolingDown || airCharges <= 0) return;
    airCharges--;
    if (direction.y > 0.4) {
       velocityY = 25; 
       playerVelocity.addScaledVector(direction.clone().setY(0).normalize(), 10);
    } else {
       playerVelocity.addScaledVector(direction, 40);
       velocityY = 5; 
    }
    if (airCharges <= 0) {
      isAirCoolingDown = true;
      setTimeout(() => { airCharges = 3; isAirCoolingDown = false; updateUI(); }, 3000);
    }
    updateUI();
    return;
  }

  if (stats.type === 'wall') {
    if (solidWalls.length >= 3) {
      const old = solidWalls.shift();
      scene.remove(old.mesh);
    }
    const wallGeo = new THREE.BoxGeometry(6, 4, 1);
    const wallMat = new THREE.MeshStandardMaterial({ color: 0x555555 });
    const wall = new THREE.Mesh(wallGeo, wallMat);
    const wallPos = camera.position.clone().addScaledVector(direction.setY(0).normalize(), 4);
    wallPos.y = 2;
    wall.position.copy(wallPos);
    wall.lookAt(camera.position.x, wallPos.y, camera.position.z);
    scene.add(wall);
    solidWalls.push({ mesh: wall, hp: 10 });
    return;
  }

  if (stats.type === 'meteor') {
      const ray = new THREE.Raycaster(camera.position, direction);
      let target = camera.position.clone().addScaledVector(direction, 40);
      if (direction.y < -0.1) {
          const t = -camera.position.y / direction.y;
          if(t > 0) target = camera.position.clone().addScaledVector(direction, t);
      }
      const skyPos = target.clone().add(new THREE.Vector3(0, 50, 0));
      const downDir = target.sub(skyPos).normalize();
      createProjectile(skyPos, downDir, 4.0, 0xff2200, 40, 0, 'spike', 120, 200);
      return;
  }

  // --- STANDARD PROJECTILES ---
  const count = stats.count || 1;
  const spread = stats.spread || 0;

  for (let i = 0; i < count; i++) {
    // Delay for rapid fire feel or instant for shotguns
    const delay = stats.auto ? i * 50 : 0; 
    
    setTimeout(() => {
        let finalDir = direction.clone();
        if (spread > 0) {
            finalDir.x += (Math.random() - 0.5) * spread;
            finalDir.y += (Math.random() - 0.5) * spread;
            finalDir.z += (Math.random() - 0.5) * spread;
            finalDir.normalize();
        }
        createProjectile(spawnPos, finalDir, 0.2, currentElement.color, stats.speed, stats.grav, stats.shape, stats.dmg, stats.life, stats.scale);
    }, delay);
  }
}

function createProjectile(pos, velDir, size, color, speed, gravity, shape, dmg, life, scaleMult=1) {
  let geometry;
  let s = size * scaleMult;

  if (shape === 'rock') geometry = new THREE.DodecahedronGeometry(s * 2, 0); 
  else if (shape === 'pebble') geometry = new THREE.TetrahedronGeometry(s, 1);
  else if (shape === 'spike') geometry = new THREE.OctahedronGeometry(s, 0);
  else if (shape === 'sharp') geometry = new THREE.TetrahedronGeometry(s, 0);
  else if (shape === 'flat') geometry = new THREE.BoxGeometry(s*5, s/2, s);
  else if (shape === 'long') geometry = new THREE.BoxGeometry(s/2, s/2, s*8);
  else geometry = new THREE.SphereGeometry(s, 8, 8);

  const mat = new THREE.MeshStandardMaterial({ 
      color: color, 
      emissive: color, 
      emissiveIntensity: 0.6, 
      roughness: 0.8 
  });
  
  const mesh = new THREE.Mesh(geometry, mat);
  mesh.position.copy(pos);
  
  if (['rock','pebble','spike'].includes(shape)) {
      mesh.rotation.set(Math.random()*Math.PI, Math.random()*Math.PI, Math.random()*Math.PI);
  } else {
      mesh.lookAt(pos.clone().add(velDir));
  }

  scene.add(mesh);
  projectiles.push({ mesh, velocity: velDir.multiplyScalar(speed), gravity, life, dmg, shape });
}

// --- Main Loop ---
function animate() {
  requestAnimationFrame(animate);
  const delta = 0.016;
  const now = Date.now();

  // Update UI timers periodically
  if (now % 10 === 0) updateUI();

  // Infinite Floor
  const snap = 2;
  const gridX = Math.round(camera.position.x / snap) * snap;
  const gridZ = Math.round(camera.position.z / snap) * snap;
  floor.position.set(gridX, 0, gridZ);
  grid.position.set(gridX, 0.05, gridZ);

  // Player Physics
  if (document.pointerLockElement === document.body) {
    const fwd = new THREE.Vector3(0, 0, -1).applyAxisAngle(new THREE.Vector3(0, 1, 0), yaw);
    const rgt = new THREE.Vector3(1, 0, 0).applyAxisAngle(new THREE.Vector3(0, 1, 0), yaw);
    const speed = isSprinting ? 18.0 : 10.0;
    const intent = new THREE.Vector3();
    if (moveForward) intent.add(fwd);
    if (moveBackward) intent.add(fwd.clone().negate());
    if (moveRight) intent.add(rgt);
    if (moveLeft) intent.add(rgt.clone().negate());
    intent.normalize().multiplyScalar(speed * delta);
    playerVelocity.add(intent);
  }

  playerVelocity.x -= playerVelocity.x * 5.0 * delta;
  playerVelocity.z -= playerVelocity.z * 5.0 * delta;
  
  const nextPos = camera.position.clone().add(new THREE.Vector3(playerVelocity.x * delta * 3, 0, playerVelocity.z * delta * 3));
  
  let wallHit = false;
  // Exact OBB (Oriented Bounding Box) Collision for Player
  for(let w of solidWalls) {
      const localPos = nextPos.clone();
      w.mesh.worldToLocal(localPos);
      if (Math.abs(localPos.x) <= 3.5 && 
          localPos.y >= -3.0 && localPos.y <= 2.5 && 
          Math.abs(localPos.z) <= 1.0) { 
          wallHit = true;
          break;
      }
  }
  
  if(!wallHit) {
      camera.position.x += playerVelocity.x * delta * 3;
      camera.position.z += playerVelocity.z * delta * 3;
  } else {
      playerVelocity.set(0,0,0);
  }

  velocityY -= 9.8 * delta;
  camera.position.y += velocityY * delta;
  if (camera.position.y < 1.7) { camera.position.y = 1.7; velocityY = 0; canJump = true; }

  // Projectiles
  for (let i = projectiles.length - 1; i >= 0; i--) {
    const p = projectiles[i];
    p.mesh.position.addScaledVector(p.velocity, delta);
    p.velocity.y -= p.gravity;
    
    if (['rock','pebble','spike'].includes(p.shape)) {
        p.mesh.rotation.x += 0.1; p.mesh.rotation.y += 0.1;
    }

    p.life--;
    if (p.mesh.position.y <= 0 || p.life <= 0) {
        scene.remove(p.mesh);
        projectiles.splice(i, 1);
        continue;
    }

    // Collision Check
    let hit = false;
    // Exact Collision Check: Walls
    for(let w = solidWalls.length - 1; w >= 0; w--) {
        const localPos = p.mesh.position.clone();
        solidWalls[w].mesh.worldToLocal(localPos);
        if (Math.abs(localPos.x) <= 3.0 && Math.abs(localPos.y) <= 2.0 && Math.abs(localPos.z) <= 0.5) {
            hit = true;
            solidWalls[w].hp -= p.dmg;
            solidWalls[w].mesh.material.color.setHex(0xffaaaa);
            const flashedMesh = solidWalls[w].mesh;
            setTimeout(()=> { if(flashedMesh.parent) flashedMesh.material.color.setHex(0x555555); }, 50);
            if(solidWalls[w].hp <= 0) {
                scene.remove(solidWalls[w].mesh);
                solidWalls.splice(w, 1);
            }
            break;
        }
    }
    
    // Enemies
    if (!hit) {
        for (let d = dummies.length - 1; d >= 0; d--) {
            if (p.mesh.position.distanceTo(dummies[d].mesh.position) < 2.5) {
                dummies[d].hp -= p.dmg;
                dummies[d].mesh.material.color.setHex(0xffffff);
                setTimeout(() => dummies[d].mesh.material.color.setHex(0xff0000), 100);
                if (dummies[d].hp <= 0) {
                    scene.remove(dummies[d].mesh);
                    dummies.splice(d, 1);
                    addXP(25);
                    setTimeout(createDummy, 3000);
                } else {
                    dummies[d].velocityY = 0.2;
                }
                hit = true;
                break;
            }
        }
    }

    if (hit) {
        scene.remove(p.mesh);
        projectiles.splice(i, 1);
    }
  }

  // Dummy Gravity
  dummies.forEach(d => {
      d.mesh.position.y += d.velocityY;
      d.velocityY -= 0.01;
      if (d.mesh.position.y < 1) { d.mesh.position.y = 1; d.velocityY = 0; }
  });

  // Hand sway
  handGroup.position.copy(camera.position);
  handGroup.rotation.copy(camera.rotation);
  if ((moveForward||moveBackward||moveLeft||moveRight) && canJump) {
      moveTimer += 0.15;
      leftHand.position.y = -0.5 + Math.sin(moveTimer)*0.05;
      rightHand.position.y = -0.5 + Math.sin(moveTimer)*0.05;
  }

  renderer.render(scene, camera);
}
animate();

window.addEventListener('resize', () => {
  camera.aspect = window.innerWidth / window.innerHeight;
  camera.updateProjectionMatrix();
  renderer.setSize(window.innerWidth, window.innerHeight);
});
